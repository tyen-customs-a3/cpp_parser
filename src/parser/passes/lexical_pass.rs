use pest::Parser;
use pest::iterators::Pair;
use crate::parser::models::{ParseContext, ParseError, RawClassDef, RawProperty, RawEnumDef, RawMacroDef};
use crate::parser::utils::get_location;

// Define the parser
#[derive(pest_derive::Parser)]
#[grammar = "parser/grammar/grammar.pest"]
pub struct LexicalParser;

// Rule enum is automatically generated by pest_derive

/// Performs the lexical pass on the input content
pub fn lexical_pass(content: &str, context: &mut ParseContext) -> Result<(), ParseError> {
    // Parse the file
    let file = LexicalParser::parse(Rule::file, content)
        .map_err(|e| ParseError::new(format!("Lexical parse error: {}", e)))?
        .next()
        .unwrap();
    
    // Process each statement
    for pair in file.into_inner() {
        match pair.as_rule() {
            Rule::class_def => {
                let raw_class = parse_raw_class(pair)?;
                context.raw_classes.push(raw_class);
            }
            Rule::enum_block => {
                let raw_enum = parse_raw_enum(pair)?;
                context.raw_enums.push(raw_enum);
            }
            Rule::macro_declaration | Rule::macro_call_statement => {
                let raw_macro = parse_raw_macro(pair)?;
                context.raw_macros.push(raw_macro);
            }
            Rule::delete_statement => {
                // Just ignore delete statements for now
                // In a more complete implementation, we would handle them
            }
            _ => {}
        }
    }
    
    Ok(())
}

/// Parses a raw class definition
fn parse_raw_class(pair: Pair<Rule>) -> Result<RawClassDef, ParseError> {
    let location = get_location(pair.as_span().start_pos());
    let raw_text = pair.as_str().to_string();
    
    // Get the class header
    let mut class_name = String::new();
    let mut parent_name = None;
    let mut properties = Vec::new();
    let mut nested_classes = Vec::new();
    
    // Process the class parts
    for inner_pair in pair.into_inner() {
        match inner_pair.as_rule() {
            Rule::class_header => {
                // Process the class header
                for header_part in inner_pair.into_inner() {
                    match header_part.as_rule() {
                        Rule::class_identifier => {
                            // First identifier is the class name
                            if class_name.is_empty() {
                                class_name = header_part.as_str().to_string();
                            } else {
                                // Second identifier is the parent class
                                parent_name = Some(header_part.as_str().to_string());
                            }
                        }
                        _ => {}
                    }
                }
            }
            Rule::class_body => {
                // Process the class body
                for body_part in inner_pair.into_inner() {
                    match body_part.as_rule() {
                        Rule::property => {
                            let raw_property = parse_raw_property(body_part)?;
                            properties.push(raw_property);
                        }
                        Rule::class_def => {
                            let nested_class = parse_raw_class(body_part)?;
                            nested_classes.push(nested_class);
                        }
                        Rule::delete_statement => {
                            // Just ignore delete statements for now
                            // In a more complete implementation, we would handle them
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
    }
    
    // Create the raw class definition
    let mut raw_class = RawClassDef::new(class_name, location, raw_text);
    
    // Set the parent name if present
    if let Some(parent) = parent_name {
        raw_class.parent_name = Some(parent);
    }
    
    // Add properties and nested classes
    raw_class.properties = properties;
    raw_class.nested_classes = nested_classes;
    
    Ok(raw_class)
}

/// Parses a raw property
fn parse_raw_property(pair: Pair<Rule>) -> Result<RawProperty, ParseError> {
    let location = get_location(pair.as_span().start_pos());
    let raw_text = pair.as_str().to_string();
    
    let mut property_name = String::new();
    let mut is_array = false;
    let mut raw_value = String::new();
    
    // Process the property parts
    for inner_pair in pair.into_inner() {
        match inner_pair.as_rule() {
            Rule::property_name => {
                property_name = inner_pair.as_str().to_string();
            }
            Rule::array_suffix => {
                is_array = true;
            }
            Rule::value => {
                raw_value = inner_pair.as_str().to_string();
            }
            _ => {}
        }
    }
    
    // Create the raw property
    let raw_property = RawProperty::new(property_name, is_array, raw_value, location, raw_text);
    
    Ok(raw_property)
}

/// Parses a raw enum definition
fn parse_raw_enum(pair: Pair<Rule>) -> Result<RawEnumDef, ParseError> {
    let location = get_location(pair.as_span().start_pos());
    let raw_text = pair.as_str().to_string();
    
    // Create the raw enum definition
    let raw_enum = RawEnumDef::new(location, raw_text);
    
    Ok(raw_enum)
}

/// Parses a raw macro definition
fn parse_raw_macro(pair: Pair<Rule>) -> Result<RawMacroDef, ParseError> {
    let raw_text = pair.as_str().to_string();
    
    // Extract the macro name and parameters
    let mut name = String::new();
    let mut params = String::new();
    
    // For simplicity, we'll just extract the first identifier as the name
    // and everything else as parameters
    for inner_pair in pair.into_inner() {
        if inner_pair.as_rule() == Rule::identifier {
            name = inner_pair.as_str().to_string();
            break;
        }
    }
    
    // Create the raw macro definition
    let raw_macro = RawMacroDef::new(name, params, raw_text);
    
    Ok(raw_macro)
} 